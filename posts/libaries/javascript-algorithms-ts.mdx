---
title: "JavaScript algorithms TS"
publishedAt: "2022-06-14"
excerpt: "Algorithms with solutions made written in JavaScript with TypeScript"
englishOnly: "true"
technologies: ["SiTypescript"]
author: "Bojan Jagetic"
inPreparation: false
banner: "bernd-dittrich-W1NsOMhU8hI-unsplash_ugoyld"
tags: [{ slug: "", name: "project" }, {slug: "", name: "tutorial"}]
---

## Introduction

Four common algorithms with solutions written in Typescript. This is my starting point working with TypeScript so this project is nothing special. Idea was to write solutions
for the algorithm problems, which will be run through commander, when the application is started commander prompt 4 choices. When user chooses one from the list it get executed with the execution time.
I hope I will add more in near future but for now it was just a good excercise.

## Fibonnaci numbers

This is well known algorithm if not the best known because everybody was doing it at least once. <Link href="https://en.wikipedia.org/wiki/Fibonacci_number">Fibonnaci numbers</Link> or sequence is a 
sequence of numbers that is calculated by adding values of two preceding numbers, 
also known as golden ratio which can be found in nature. <NewLine/>
We count the sequence starting with the index <Adjusted>n = 0</Adjusted> which has value of <Adjusted>0</Adjusted>. Next in sequence is <Adjusted>n = 1 </Adjusted> which has the value of <Adjusted>1</Adjusted>.
Next in sequence is <Adjusted>n = 2 </Adjusted> with value <Adjusted> 1 </Adjusted>. If you ask why , it is simple we add values of previous two and that is <Adjusted> 0 + 1 </Adjusted>, to be easier for you to understand
here is the formula. 

Formula for calculating Fibonnaci number is : 
```
F(n) = F(n-2) + F(n-1)
```

So if we want to calculate Fibonacci number for 3 result will be <Adjusted> F(1) + F(2) = 1 + 1 = 2 </Adjusted> as we got already Fibonacci for 1 and 2 which is 1 and 1.

### Fibonnaci Solution

My solution is:

```javascript
let storedFibNums: any = {};
export const calculateFibonacci = (n: number): number => {
    if (n <= 1) return n;
    if (storedFibNums[n]) {
        return storedFibNums[n]
    }
    storedFibNums[n] = calculateFibonacci(n - 1) + calculateFibonacci(n - 2)
    return storedFibNums[n];
}
```


## Calculate century

This is really simple one, if you want it to be simple. The point of the algorithm is that you are provided year and you have to return in which century it belongs.
For me easiest solution was to divide year by 100 and then use <Adjusted>Math.ceil</Adjusted> to get century.
<Link href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/ceil">Math.ceil</Link> is great for this solution because it will round number to greater than or equal to a given number.

### Century Solution
Solution is pretty simple, it took only 2 lines of code. 

```javascript
export const century = (year: number) => {
    const cent = year / 100;
    return Math.ceil(cent)
}
```


## Palindrome
What is Palindrome?

<QouteComponent>a word, phrase, or sequence that reads the same backwards as forwards, e.g. madam or nurses run.</QouteComponent>
So basically you are given a word and you need to check wheather it is palindrome.
### Palindrome Solution
Solution for this one is also very trivial, you just need to loop through the word from the behind and check if it match with the given word.

```javascript
export const isPalindrom = (inputString: string): boolean => {
    let palindrom = "";
    for (let i = inputString.length - 1; i >= 0; i--) {
        palindrom += inputString[i];
    }
    if (palindrom === inputString) {
        return true
    }
    return false;
}
```

## First duplicate
You are given array of numbers and you have to return first number that is duplicate. Array provided can be of size <Adjusted> n </Adjusted> so this means that we can have array with million of elements.
### First duplicate Solution
When we measure performance as well, in the million sized array, <Adjusted>for</Adjusted> loop can be an issue. <Adjusted>While</Adjusted> can be as well even though it is faster than for loop. 
Best solution I found is to create <Adjusted>Set</Adjusted> and loop over array of numbers, check if we have it in Set if not add it. So we will use <Adjusted>Set.has()</Adjusted>  instead of having dual loop and if we have it in set 
we return it.

```javascript
export const removeFirstDuplicate = (a: number[]) => {
    const x = new Set<Number>()
    for (const num of a) {
        if (x.has(num)) {
            return num
        } else {
            x.add(num)
        }
    }
    return -1
}
```

Algorithms are great way for improving your technical skills and the way of thinking, so it is great excercise and way of learning. So I strongly suggest to checkout if you dont already know for 
this great platforms where you can solve algorithm problems, my personal favorites are <Link href="https://leetcode.com/">Leetcode</Link> and <Link href="https://codesignal.com/">Code Signal</Link>



<GithubCardRepository>basskibo/js-algorithms-ts</GithubCardRepository>

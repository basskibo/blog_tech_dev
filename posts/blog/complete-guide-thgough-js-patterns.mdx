---
title: "Mastering JavaScript Design Patterns: A Comprehensive Guide"
publishedAt: "2022-07-13"
excerpt: "Design patterns are not just for experienced developers. Even if you're just starting out with JavaScript, you can benefit from learning about design patterns and how to use them in your projects"
englishOnly: "true"
banner: "bernd-dittrich-W1NsOMhU8hI-unsplash_ugoyld"
date: "June 15, 2022"
featuredImage: "https://res.cloudinary.com/dr1sm5gnj/image/upload/q_60/v1657728838/igutech/joel-naren-V8p9ql6-wGo-unsplash_gsd3mt.jpg"
author: "Bojan Jagetic"
tags: [{  slug: "design-pattern", name: "design pattern"  }, { slug: "js", name: "javascript" }]
inPreparation: false
---

## Introduction

If you're new to JavaScript design patterns, this post is for you. We'll start with the basics, including an overview of what design patterns are and why they are important. From there, we'll move on to some of the most common design patterns in JavaScript, including the singleton pattern, the factory pattern, and the observer pattern.
JavaScript design patterns are reusable solutions to common programming problems that can improve the organization, readability, and maintainability of your code. In this post, we'll introduce some of the most popular and useful design patterns in JavaScript and explain how to use them in your projects.




### What is a Design Pattern

Design patterns are a key concept in software engineering and are especially important in JavaScript, where the dynamic and flexible nature of the language can make it difficult to write clean and maintainable code. In this post, we'll explore the benefits of using design patterns in JavaScript and provide some practical examples of how to apply them in your projects.
As Wikipedia says on <Link href="https://en.wikipedia.org/wiki/Software_design_pattern" >Software design patterns </Link>:

<QouteComponent>In software engineering, a software design pattern is a general, reusable solution to a commonly occurring problem within a given context in software design. It is not a finished design that can be transformed directly into source or machine code. Rather, it is a description or template for how to solve a problem that can be used in many different situations. Design patterns are formalized best practices that the programmer can use to solve common problems when designing an application or system.</QouteComponent>


Find more info <Link href="https://blog.logrocket.com/design-patterns-in-node-js/"> on this link </Link>

### Anti-patterns

## Classification 

sa jfas gjai gail ji

## Creational Design Patterns
### Singleton Pattern

As is often said, old but gold, <Adjusted>Singleton</Adjusted> pattern is one of the most used patterns.
The singleton pattern ensures that a class <b>has one and only one instance</b>, and provides a global point of access to it. 
In simple words, it consists of an object which cannot be chnaged or modified. It is usefull when we want to be sure that we have immutable single point of truth for our application.

What makes Singleton, is global access to the instance usually with <code>Singleton.getInstance()</code> so we do not call <code>new Singleton()</code> directly. 
<CloudinaryImage src="https://res.cloudinary.com/dr1sm5gnj/image/upload/v1672253243/igutech/blogs/resources/design_patterns/singleton1_z81frp.png" alt="Singleton pattern" text="Singleton pattern" />

Here's an example of a singleton in JavaScript:

```javascript
let counter = 0;
class Users {
  constructor() {
    // Check whether or not weâ€™ve already instantiated a Users
    if (!Users.instance) {
      this._data = [];
      this._counter = counter;
      Users.instance = this;
    }
  }
  getInstance() {
    if (!Users.instance) {
      instance = new Users();
    }
    return instance;
  }

  increment() {
    return this._counter++;
  }

  getCounter() {
    return this._counter;
  }
  add(item) {
    this._data.push(item);
  }

  print(id) {
    const user = this._data.find((userData) => userData.id === id);
    return `Users name with id:${user.id} is ${user.name}`;
  }
}

const instance = new Users();
const singleton = Object.freeze(instance);

export default instance;

```


Lets summarize Singleton pattern and most important thing you should know:
<LgList>
  <li>Ensures we have only one instance of the class or object</li>
  <li>It is shared globally between multiple files inside application, also all imports have access and reference to the same instance</li>
  <li>It can be mutable or immutable, but with singleton we need to make sure it is thread-safe if used in multiple threads where   </li>
  <li></li>

</LgList>

### Factory Pattern

The factory pattern is a creational pattern that provides an interface for creating objects in a super class, but allows subclasses to alter the type of objects that will be created.

Here's an example of a factory in JavaScript:

```javascript
class ShapeFactory {
  createShape(type) {
    if (type === 'circle') {
      return new Circle();
    } else if (type === 'square') {
      return new Square();
    }
  }
}

class Circle {
  draw() {
    console.log('Drawing a circle');
  }
}

class Square {
  draw() {
    console.log('Drawing a square');
  }
}

const shapeFactory = new ShapeFactory();
const circle = shapeFactory.createShape('circle');
circle.draw(); // "Drawing a circle"
const square = shapeFactory.createShape('square');
square.draw(); // "Drawing a square"
```


### Builder pattern


### Module Pattern

### Prototype Pattern

## Structural Design Patterns

### Decorator
### Proxy Pattern


### Adapter Pattern

### Facade Pattern

## Behavioral Design Patterns

### Chain of Responsibility Pattern
### Observer Pattern

The observer pattern is a behavioral pattern that allows an object (the subject) to notify other objects (the observers) when its state changes. This pattern is often used for event-driven programming.

Here's an example of the observer pattern in JavaScript:

```javascript
class Subject {
  constructor() {
    this.observers = [];
  }

  subscribe(observer) {
    this.observers.push(observer);
  }

  unsubscribe(observer) {
    this.observers = this.observers.filter(o => o !== observer);
  }

  notify(data) {
    this.observers.forEach(observer => observer.update(data));
  }
}

class Observer {
  constructor(name) {
    this.name = name;
  }

  update(data) {
    console.log(`${this.name} received update: ${data}`);
  }
}

const subject = new Subject();
const observer1 = new Observer('observer 1');
const observer2 = new Observer('observer 2');

subject.subscribe(observer1);
subject.subscribe(observer2);
subject.notify('some data');
// "observer 1 received update: some data"
// "observer 2 received update: some data"
```

### Iterator Pattern


## Conclusion

<Iframe url="https://stackblitz.com/edit/js-ra2knw?devToolsHeight=33&embed=1&file=index.js&theme=dark" title="Module pattern" />
